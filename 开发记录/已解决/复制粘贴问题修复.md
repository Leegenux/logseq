# 问题描述

## 问题现象
选择若干个块，进行复制后粘贴正常工作；但使用剪切功能（Cmd + X）时，虽然提示"复制成功"，但粘贴时无内容显示，且原块未被删除。

## 复现步骤
1. 在页面中选择一个或多个块
2. 按下 Cmd + X 进行剪切操作（界面提示"复制成功"）
3. 移动光标到目标位置
4. 按下 Cmd + V 尝试粘贴

## 期望行为
剪切操作应删除选中的块，并在粘贴时将这些块移动到新位置。

## 实际行为
- 执行剪切操作时提示"复制成功"
- 原块未被删除
- 粘贴操作无效，无内容被粘贴

## 错误日志
在执行剪切粘贴操作失败时，终端输出以下错误：
```
"Request Autofill.setAddresses failed. {"code":-32601,"message":"'Autofill.setAddresses' wasn't found"}"

compilation error: file file:///Users/evan/logseq/static/index.html#/all-journals line 1 element stylesheet
xsl:version is missing: document may not be a stylesheet
```

# 相关代码

## 关键函数分析

### 复制与剪切功能比较

LogSeq的复制和剪切功能主要在`src/main/frontend/handler/editor.cljs`文件中实现：

1. **复制功能**：
```clojure
(defn copy-selection-blocks
  [html?]
  (when-let [blocks (seq (state/get-selection-blocks))]
    (let [repo (state/get-current-repo)
          ids (distinct (keep #(when-let [id (dom/attr % "blockid")]
                                 (uuid id)) blocks))
          [top-level-block-uuids content] (compose-copied-blocks-contents repo ids)
          block (db/entity [:block/uuid (first ids)])]
      (when block
        (let [html (export-html/export-blocks-as-html repo top-level-block-uuids nil)
              copied-blocks (get-all-blocks-by-ids repo top-level-block-uuids)]
          (common-handler/copy-to-clipboard-without-id-property! (:block/format block) content (when html? html) copied-blocks))
        (state/set-block-op-type! :copy)
        (notification/show! "Copied!" :success)))))
```

2. **剪切功能**：
```clojure
(defn cut-selection-blocks
  [copy?]
  (when copy? (copy-selection-blocks true))
  (state/set-block-op-type! :cut)
  (when-let [blocks (seq (get-selected-blocks))]
    ;; remove embeds, references and queries
    (let [dom-blocks (remove (fn [block]
                              (or (= "true" (dom/attr block "data-transclude"))
                                  (= "true" (dom/attr block "data-query")))) blocks)
          dom-blocks (if (seq dom-blocks) dom-blocks
                         (remove (fn [block]
                                   (= "true" (dom/attr block "data-transclude"))) blocks))]
      (when (seq dom-blocks)
        (let [repo (state/get-current-repo)
              block-uuids (distinct (map #(uuid (dom/attr % "blockid")) dom-blocks))
              lookup-refs (map (fn [id] [:block/uuid id]) block-uuids)
              blocks (db/pull-many repo '[*] lookup-refs)
              top-level-blocks (outliner-core/get-top-level-blocks blocks)
              sorted-blocks (mapcat (fn [block]
                                      (tree/get-sorted-block-and-children repo (:db/id block)))
                                    top-level-blocks)]
          (delete-blocks! repo (map :block/uuid sorted-blocks) sorted-blocks dom-blocks))))))
```

3. **剪切快捷键处理函数**：
```clojure
(defn shortcut-cut
  "shortcut cut action:
  * when in selection mode, cut selected blocks
  * when in edit mode with text selected, cut selected text
  * otherwise nothing need to be handled."
  [e]
  (cond
    (state/selection?)
    (shortcut-cut-selection e)

    (and (state/editing?) (util/input-text-selected?
                           (gdom/getElement (state/get-edit-input-id))))
    (keydown-backspace-handler true e)

    (whiteboard?)
    (.cut (state/active-tldraw-app))

    :else
    nil))
```

4. **粘贴处理**（在`src/main/frontend/handler/paste.cljs`中）：
```clojure
(defn- paste-copied-blocks-or-text
  [input text e html]
  (util/stop e)
  (->
   (p/let [copied-blocks (get-copied-blocks)]
     (if (seq copied-blocks)
       ;; Handle internal paste
       (let [revert-cut-txs (get-revert-cut-txs copied-blocks)
             keep-uuid? (= (state/get-block-op-type) :cut)]
         (editor-handler/paste-blocks copied-blocks {:revert-cut-txs revert-cut-txs
                                                     :keep-uuid? keep-uuid?}))
       (paste-copied-text input text html)))
   (p/catch (fn [error]
              (log/error :msg "Paste failed" :exception error)
              (state/pub-event! [:capture-error {:error error
                                                 :payload {:type ::paste-copied-blocks-or-text}}])))))
```

## 问题所在

根据代码分析和终端错误日志，问题点包括：

1. **删除块操作失败**：在`cut-selection-blocks`函数中，调用了`delete-blocks!`函数来删除选中的块，但这个操作可能失败。

2. **状态标记问题**：虽然在剪切操作中设置了`(state/set-block-op-type! :cut)`，但可能这个状态没有被正确处理。

3. **复制到剪贴板的内容不正确**：通过`copy-selection-blocks true`复制内容，但这个内容在粘贴时可能无法被正确识别。

4. **粘贴处理流程错误**：`paste-copied-blocks-or-text`函数中，`get-copied-blocks`可能无法检索到剪切的块，或者`get-revert-cut-txs`函数无法正确处理剪切操作的回滚事务。

5. **block-op-type状态设置与检查**：虽然设置了`:cut`状态，但在粘贴操作中可能没有正确检查这个状态或者状态被某些操作重置。

6. **异步操作中的错误**：终端出现的`Autofill.setAddresses`错误可能表明在处理剪贴板操作时发生了异步问题，这可能与浏览器API的调用有关。

7. **样式表错误**：样式表相关的错误可能表明在渲染过程中出现了问题，这可能影响剪切后的UI更新。

## 调试建议

针对上述分析，建议以下调试方法：

1. 在`cut-selection-blocks`函数中增加日志，查看是否成功获取到选中的块以及是否调用了`delete-blocks!`。

2. 在`delete-blocks!`函数中增加日志，检查删除操作是否成功执行。

3. 在粘贴操作相关代码中增加日志，特别是`get-copied-blocks`和`get-revert-cut-txs`函数，检查是否正确获取到剪切的块内容。

4. 检查`state/get-block-op-type`在剪切和粘贴过程中的值变化，确认状态是否正确传递。

5. 查看剪贴板内容，确认剪切操作是否正确将内容放入剪贴板。

6. 检查浏览器的剪贴板API调用是否正确，特别是与`Autofill.setAddresses`相关的错误。

## 可能的问题原因

通过代码分析，最有可能的原因是：

1. **执行顺序问题**：在`cut-selection-blocks`函数中，首先通过`copy-selection-blocks`复制内容，然后设置`block-op-type`为`:cut`，最后才执行删除操作。如果删除操作失败，但由于之前已经设置了`:cut`状态，导致提示"复制成功"，但实际块没有被删除。

2. **异步执行问题**：在`delete-blocks!`函数中的数据库事务操作可能是异步的，但函数没有等待操作完成就返回了，导致UI上提示复制成功，但实际删除操作尚未完成或失败。

3. **剪贴板API问题**：终端中的`Autofill.setAddresses`错误表明可能是浏览器的剪贴板API调用出现了问题，这与Electron环境下的权限或API兼容性有关。

4. **状态同步问题**：粘贴操作时的`get-block-op-type`可能无法正确获取到之前设置的`:cut`状态，导致粘贴时错误地处理了剪切的内容。

# 解决方案实现

根据以上分析，以下是实现的修复方案：

## 1. 修改后的 cut-selection-blocks 函数

```clojure
(defn cut-selection-blocks
  [copy?]
  (when-let [blocks (seq (get-selected-blocks))]
    ;; 先复制内容
    (when copy? (copy-selection-blocks true))
    ;; remove embeds, references and queries
    (let [dom-blocks (remove (fn [block]
                               (or (= "true" (dom/attr block "data-transclude"))
                                   (= "true" (dom/attr block "data-query")))) blocks)
          dom-blocks (if (seq dom-blocks) 
                       dom-blocks
                       (remove (fn [block]
                                 (= "true" (dom/attr block "data-transclude"))) blocks))]
      (when (seq dom-blocks)
        (let [repo (state/get-current-repo)
              block-uuids (distinct (map #(uuid (dom/attr % "blockid")) dom-blocks))
              lookup-refs (map (fn [id] [:block/uuid id]) block-uuids)
              blocks (db/pull-many repo '[*] lookup-refs)
              top-level-blocks (outliner-core/get-top-level-blocks blocks)
              sorted-blocks (mapcat (fn [block]
                                      (tree/get-sorted-block-and-children repo (:db/id block)))
                                    top-level-blocks)]
          ;; 尝试删除块
          (try 
            (when (delete-blocks! repo (map :block/uuid sorted-blocks) sorted-blocks dom-blocks)
              ;; 删除成功后才设置 block-op-type
              (state/set-block-op-type! :cut)
              (notification/show! "Cut!" :success))
            (catch :default e
              (js/console.error "Failed to cut blocks:" e)
              (notification/show! "Cut operation failed"))))))))
```

主要改动：
1. 先执行复制操作，再处理删除流程
2. 只有在删除成功后才设置 block-op-type 为 :cut
3. 添加了错误处理，确保异常被捕获并输出到控制台

## 2. 修改后的 delete-blocks! 函数

```clojure
(defn delete-blocks!
  [repo block-uuids blocks dom-blocks]
  (when (seq block-uuids)
    (let [uuid->dom-block (zipmap block-uuids dom-blocks)
          block (first blocks)
          block-parent (get uuid->dom-block (:block/uuid block))
          sibling-block (when block-parent (util/get-prev-block-non-collapsed-non-embed block-parent))]
      (try
        (outliner-tx/transact!
         {:outliner-op :delete-blocks}
         (outliner-core/delete-blocks! blocks {}))
        (when sibling-block
          (move-to-prev-block repo sibling-block
                              (:block/format block)
                              (dom/attr sibling-block "id")
                              ""
                              true))
        true  ;; 返回成功标志
        (catch js/Error e
          (js/console.error "Error deleting blocks:" e)
          false))))) ;; 返回失败标志
```

主要改动：
1. 添加了错误处理逻辑
2. 函数现在返回布尔值，表明操作是否成功
3. 增加了日志记录，便于调试问题

## 3. 修改后的 paste-copied-blocks-or-text 函数

```clojure
(defn- paste-copied-blocks-or-text
  ;; todo: logseq/whiteboard-shapes is now text/html
  [input text e html]
  (util/stop e)
  (->
   (p/let [copied-blocks (get-copied-blocks)
           op-type (state/get-block-op-type)]
     (js/console.log "Paste operation, block-op-type:" (str op-type))
     (if (seq copied-blocks)
       ;; Handle internal paste
       (let [revert-cut-txs (get-revert-cut-txs copied-blocks)
             keep-uuid? (= op-type :cut)]
         (js/console.log "Pasting blocks with keep-uuid?:" keep-uuid?)
         (editor-handler/paste-blocks copied-blocks {:revert-cut-txs revert-cut-txs
                                                     :keep-uuid? keep-uuid?}))
       (do
         (js/console.log "No copied blocks found, pasting as text")
         (paste-copied-text input text html))))
   (p/catch (fn [error]
              (log/error :msg "Paste failed" :exception error)
              (state/pub-event! [:capture-error {:error error
                                                 :payload {:type ::paste-copied-blocks-or-text}}])))))
```

主要改动：
1. 将状态检查提前，避免在嵌套调用中可能导致的问题
2. 添加了详细的日志记录，便于调试
3. 明确区分了不同的粘贴路径

## 解决方案解释

1. **修复执行顺序问题**：现在只有在成功删除块后才会设置`block-op-type`为`:cut`，避免了之前的状态不一致问题。

2. **增强错误处理**：为各个关键函数添加了错误处理逻辑，确保异常情况被正确处理，并防止应用崩溃。

3. **改善状态管理**：在粘贴操作中提前获取和记录状态，确保在整个操作过程中状态的一致性。

4. **增加调试信息**：添加了更多的日志记录，便于定位和解决问题。

关于终端中出现的`Autofill.setAddresses`错误，这可能是Electron环境中的浏览器API调用问题，与我们的代码修改无直接关系，但通过加强错误处理机制，可以防止这类错误导致主要功能失效。

样式表相关的错误可能是页面渲染过程中的次要问题，通过确保核心功能的正确执行，可以减少这些问题对用户体验的影响。

# 最终解决方案

经过深入分析，我们发现问题的根本原因是在`datascript.cljc`文件中的`replace-ref-with-content`函数中，当处理被引用块的删除操作时，没有正确处理可能出现的`nil`值。

## 实际错误原因

剪切粘贴操作失败的具体错误是：

```
Cannot store nil as a value at [:db/add 14656 :block/path-refs nil]
```

这表明系统尝试添加一个`nil`值作为`:block/path-refs`的引用，而DataScript数据库不允许将`nil`存储为引用值。

当用户执行剪切操作时，系统会删除原始块，并尝试更新任何引用这些块的内容。在这个过程中，如果遇到`:block/id`或内容为`nil`的情况，代码没有正确处理，导致尝试创建包含`nil`值的数据库事务，从而引发错误。

## 修复方案

我们对`/Users/evan/logseq/src/main/frontend/modules/outliner/datascript.cljc`文件中的`replace-ref-with-content`函数进行了修改：

```clojure
(defn replace-ref-with-content
  [txs opts]
  (if (and (= :delete-blocks (:outliner-op opts))
            (empty? (:uuid-changed opts)))
    (let [retracted-block-ids (->> (keep (fn [tx]
                                          (when (and (vector? tx)
                                                      (= :db.fn/retractEntity (first tx)))
                                            (second tx))) txs))
          retracted-blocks (map db/entity retracted-block-ids)
          retracted-tx (->> (for [block retracted-blocks]
                              (let [refs (:block/_refs block)]
                                (map (fn [ref]
                                      (let [id (:db/id ref)
                                            block-content (when-let [content (:block/content block)]
                                                          (property/remove-properties (:block/format block) content))
                                            ref-content (:block/content ref)]
                                        (if (and block-content ref-content)
                                          (let [new-content (-> ref-content
                                                                (string/replace (re-pattern (util/format "(?i){{embed \\(\\(%s\\)\\)\\s?}}" (str (:block/uuid block))))
                                                                                block-content)
                                                                (string/replace (block-ref/->block-ref (str (:block/uuid block)))
                                                                                block-content))]
                                            {:tx [[:db/retract (:db/id ref) :block/refs (:db/id block)]
                                                  (when (:db/id block) 
                                                    [:db/retract (:db/id ref) :block/path-refs (:db/id block)])
                                                  [:db/add id :block/content new-content]]
                                              :revert-tx [[:db/add id :block/content ref-content]]})
                                          ;; 如果内容为空，只处理引用关系
                                          {:tx [[:db/retract (:db/id ref) :block/refs (:db/id block)]
                                                (when (:db/id block)
                                                  [:db/retract (:db/id ref) :block/path-refs (:db/id block)])]
                                            :revert-tx []}))) refs)))
                            (apply concat))
          retracted-tx' (mapcat (fn [tx-map]
                                  (filter some? (:tx tx-map))) retracted-tx)
          revert-tx (mapcat :revert-tx retracted-tx)]
      (when (seq retracted-tx')
        (state/set-state! [:editor/last-replace-ref-content-tx (state/get-current-repo)]
                          {:retracted-block-ids retracted-block-ids
                            :revert-tx revert-tx}))
      (concat txs retracted-tx'))
    txs))
```

主要修改点包括：

1. 添加对`block/content`的空值检查，确保只有在内容存在时才进行处理：
   ```clojure
   block-content (when-let [content (:block/content block)]
                   (property/remove-properties (:block/format block) content))
   ```

2. 添加对`block/id`的空值检查，确保只有在ID存在时才添加或移除path-refs：
   ```clojure
   (when (:db/id block) 
     [:db/retract (:db/id ref) :block/path-refs (:db/id block)])
   ```

3. 修改事务处理逻辑，使用`filter some?`过滤掉可能为`nil`的事务项：
   ```clojure
   retracted-tx' (mapcat (fn [tx-map]
                           (filter some? (:tx tx-map))) retracted-tx)
   ```

4. 为空内容情况提供替代方案，确保引用关系被正确清理：
   ```clojure
   ;; 如果内容为空，只处理引用关系
   {:tx [[:db/retract (:db/id ref) :block/refs (:db/id block)]
         (when (:db/id block)
           [:db/retract (:db/id ref) :block/path-refs (:db/id block)])]
    :revert-tx []}
   ```

## 效果验证

修复后，用户能够正常执行剪切和粘贴操作，具体表现为：

1. 执行剪切操作（Cmd + X）时，原始块被成功删除
2. 粘贴操作（Cmd + V）能够成功将剪切的块移动到新位置
3. 不再出现"Cannot store nil as a value"错误

这个修复解决了剪切粘贴功能的核心问题，使用户能够按预期使用这个基本功能。

## 总结

通过对DataScript事务处理逻辑的深入分析，我们发现并修复了一个关键问题：系统在处理块引用时，没有正确处理可能出现的`nil`值。通过添加适当的空值检查和事务过滤，我们确保了即使在复杂的引用关系中，系统也能正确处理块的删除和移动操作，从而修复了剪切粘贴功能。