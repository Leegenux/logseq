# LogSeq 长期使用性能问题分析

经过对 LogSeq 代码库的分析，我发现了几个可能导致长期使用后性能下降的关键因素：

## 1. 版本文件积累

LogSeq 会为每次编辑的文件创建版本历史文件，存储在 `logseq/version-files/local` 目录下。虽然代码中有尝试限制版本文件数量的机制（保留最新的 6 个版本），但在实际使用中可能存在以下问题：

```clojure
(defn- truncate-old-versioned-files!
  "reserve the latest 6 version files"
  [dir]
  (let [files (fs/readdirSync dir (clj->js {:withFileTypes true}))
        files (mapv #(.-name %) files)
        old-versioned-files (drop 6 (reverse (sort files)))]
    (doseq [file old-versioned-files]
      (fs-extra/removeSync (node-path/join dir file)))))
```

- 如果用户频繁编辑大量文件，这些版本文件会迅速积累
- 版本文件清理可能不够彻底，导致文件系统负担增加
- 在移动设备上，这些文件的 I/O 操作可能更加耗费资源

## 2. 备份文件积累

除了版本文件，LogSeq 还会在 `logseq/bak` 目录下创建备份文件，这些文件同样会随着使用时间增加而积累：

```clojure
(def backup-dir "logseq/bak")
(def version-file-dir "logseq/version-files/local")
```

## 3. 大型图谱性能问题

代码中有明确的警告，当文件数量过多时会导致性能问题：

```clojure
(when (>= (count files) 10000)
  (state/pub-event!
   [:notification/show {:content "It seems that you are trying to open a Logseq graph folder that contains an excessive number of files, This might lead to performance issues."
                        :status :warning
                        :clear? true}]))
```

这表明 LogSeq 在处理大量文件时存在性能瓶颈。

## 4. 缓存管理问题

### 块 AST 缓存限制

LogSeq 对块 AST 的缓存有大小限制，但实现方式可能导致性能问题：

```clojure
(defn add-block-ast-cache!
  [block-uuid content ast]
  (when (and block-uuid content ast)
    (let [new-value (assoc-in @blocks-ast-cache [block-uuid content] ast)
          new-value (if (> (count new-value) 10000)
                      (into {} (take 5000 new-value))
                      new-value)]
      (reset! blocks-ast-cache new-value))))
```

当缓存超过 10000 项时，会截取前 5000 项，这种方式可能导致：
- 频繁的大规模缓存重建
- 丢弃可能仍然有用的缓存项
- 内存使用效率低下

### IndexedDB 性能问题

LogSeq 使用 IndexedDB 存储数据，但没有明确的数据清理或优化机制：

```clojure
(defn clear-idb!
  []
  (when @store
    (->
     (p/let [_ (idb-keyval/clear @store)
             dbs (js/window.indexedDB.databases)]
       (doseq [db dbs]
         (js/window.indexedDB.deleteDatabase (gobj/get db "name"))))
     (p/catch (fn [_e])))))
```

随着数据库大小增长，查询性能可能会显著下降。

## 5. 插件性能问题

代码中有检测插件加载时间的机制，当插件加载时间超过 6 秒时会发出警告：

```clojure
(when (and (number? end)
           ;; valid end time
           (> end 0)
           ;; greater than 6s
           (> (- end (.-s v)) 6000))
  v)
```

长期使用后安装的插件增多，可能导致启动和运行时性能下降。

## 6. 查询性能问题

对于复杂查询，LogSeq 会禁用自动刷新以避免性能问题：

```clojure
(rum/defc query-refresh-button
  [query-time {:keys [on-mouse-down full-text-search?]}]
  (ui/tippy
   {:html  [:div
            [:p
             (if full-text-search?
               [:span "Full-text search results will not be refreshed automatically."]
               [:span (str "This query takes " (int query-time) "ms to finish, it's a bit slow so that auto refresh is disabled.")])]
            [:p
             "Click the refresh button instead if you want to see the latest result."]]
```

随着数据库增大，查询性能会进一步下降。

## 7. 内存泄漏可能性

代码中存在一些可能导致内存泄漏的模式：

```clojure
(syncGCTimer = setInterval(() => {
  if (syncActors.size > 100) {
    for (const [k, v] of syncActors) {
      if (v.settled) {
        syncActors.delete(k)
      }
    }
  }
}, 1000 * 60 * 30))
```

这段代码每 30 分钟才清理一次已完成的同步操作，可能导致内存占用增加。

## 改善建议

1. **定期清理**：定期手动清理 `logseq/bak` 和 `logseq/version-files` 目录
2. **重建索引**：当性能明显下降时，尝试重建索引（通过 "重新索引当前图谱" 功能）
3. **分割图谱**：将大型图谱分割成多个较小的图谱
4. **禁用不必要的插件**：特别是那些加载时间长的插件
5. **定期导出和重新导入**：导出数据，清理数据库，然后重新导入
6. **监控文件数量**：保持图谱中的文件数量在合理范围内（低于 10,000 个文件） 